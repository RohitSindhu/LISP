;; ########################################################################
;;                     ROHIT SINDHU
;;                   SINDH010@UMN.EDU
;; ########################################################################

;; ########################### 8 Puzzle Problem ##########################

;; STATE :: (cons (cons BOARD_ARRAY PARENT) COST)

(defvar numExpanded 0)  ; Number of nodes expanded

;; Heuristic function to return the number of misplaced tiles in state
;; INPUT
;;      state  :: state for heuristic value is to be calculated
;; OUTPUT
;;      return :: Number of misplaced tiles
(defun heuristicFunc (state)
    (let ((val 0))
        (if (not (eq  1 (aref state 0 0))) (incf val 1))
        (if (not (eq  2 (aref state 0 1))) (incf val 1))
        (if (not (eq  3 (aref state 0 2))) (incf val 1))
        (if (not (eq  4 (aref state 1 0))) (incf val 1))
        (if (not (eq  5 (aref state 1 1))) (incf val 1))
        (if (not (eq  6 (aref state 1 2))) (incf val 1))
        (if (not (eq  7 (aref state 2 0))) (incf val 1))
        (if (not (eq  8 (aref state 2 1))) (incf val 1))
        (if (not (eq 'E (aref state 2 2))) (incf val 1))
        (return-from heuristicFunc val)
    )
)

;; Function to find the positon of empty tile
;; INPUT
;;      state  :: any system state
;; OUTPUT
;;      return ::cons containing position of empty tile
(defun findPlace (state)
    (dotimes (i 3)
        (dotimes (j 3)
            (if (eq 'E (aref state i j)) (return-from findPlace (cons i j)))
        )
    )
)

;; Function to return deep copy of an state
;; INPUT
;;      state  :: any system state
;; OUTPUT
;;      return :: deep copy of the state
(defun copy-arr (state)
    (let ((temp (make-array '(3 3))))
        (dotimes (i 3)
            (dotimes (j 3)
                (setf (aref temp i j) (aref state i j))
            )
        )
        (return-from copy-arr temp)
    )
)

;; Function to generate next state in state space depending on the action :- dir
;; INPUT
;;      state  :: state for which child is to be generated
;;      dir    :: up (1) , down (2) , left (3) , right (4)
;; OUTPUT
;;      return :: Generated child depending on direction or nil in case of no-op
(defun generateChild (state dir)
    (let ( ( child ( copy-arr state ) ) ( place ( findPlace state ) ) )    ;; state getting modified
        (case dir
            (1  ;; UP
                (if (equal 0 (car place)) (return-from generateChild nil) )
                (setf (aref child (car place) (cdr place)) (aref child (- (car place) 1) (cdr place)))
                (setf (aref child (- (car place) 1) (cdr place)) 'E)
                (return-from generateChild child)
            )
            (2  ;; DOWN
                (if (equal 2 (car place)) (return-from generateChild nil) )
                (setf (aref child (car place) (cdr place)) (aref child (+ 1 (car place)) (cdr place)))
                (setf (aref child (+ 1 (car place)) (cdr place)) 'E)
                (return-from generateChild child)
            )
            (3  ;; LEFT
                (if (equal 0 (cdr place)) (return-from generateChild nil) )
                (setf (aref child (car place) (cdr place)) (aref child (car place) (- (cdr place) 1)))
                (setf (aref child (car place) (- (cdr place) 1)) 'E)
                (return-from generateChild child)
            )
            (4  ;; RIGHT
                (if (equal 2 (cdr place)) (return-from generateChild nil) )
                (setf (aref child (car place) (cdr place)) (aref child (car place) (+ 1 (cdr place))))
                (setf (aref child (car place) (+ 1 (cdr place))) 'E)
                (return-from generateChild child)
            )
        )
    )
)

;; Function to find nodes next states to be generated from current state
;; INPUT
;;      state  :: state on which actions are to be taken
;;      queue  :: frontier on which nodes to expanded resides
;;      visited :: list of expanded nodes
;; OUTPUT
;;      return :: states generated by doing actions
(defun getChild (state queue visited)
    (let (  
            ;; genearte possible child states
            (upChild    (generateChild  (caar state) 1))
            (downChild  (generateChild  (caar state) 2))
            (leftChild  (generateChild  (caar state) 3))
            (rightChild (generateChild  (caar state) 4))
        )
        ;; ############################################################
        (let ( ( childList nil ) 
               ( tempList (list upChild downChild leftChild rightChild) ) 
            )
            ;; Add child states as candidate states with the cost value : g(x) + h(x)
            (dolist ( temp tempList )
                (if (not (equal nil temp)) 
                    (setq childList 
                          (append 
                            childList 
                            (list (cons (cons temp (caar state)) 
                                (+ (heuristicFunc temp) 
                                   (+ 1 (- (cdr state) (heuristicFunc (caar state))))
                                ) 
                            ) )
                          )
                    )
                )
            )
            ;; Remove states which are in visited list
            (dolist ( v visited )
                ( setq childList (remove (car v) childList :key #'caar :test #'equalp) ) 
            )
            ;; Check if a matching state in frontier has higher cost value
            ;; If yes update the value as we have reached it via lower lost
            (dolist ( v queue )
                    (let ( ( fd  (find (caar v) childList :key #'caar ) ) ) 
                        (if (not (equal nil fd)) 
                                (if (<  (cdr fd ) (cdr v) )  
                                    (setf (cdr v) (cdr fd ) )
                                )
                        )
                    )
            )
            ;; Remove from childList as we have already updated the queue
            (dolist ( v queue )
                ( setq childList (remove (caar v) childList :key #'caar :test #'equalp) ) 
            )
            (format t "~%New States Generated This Expansion")
            (dolist ( chd childList )
                (print (caar chd))
            )
            (format t "~%")
            (return-from getChild childList)
        )
        ;; ############################################################
    )
)

;; Recursive function to solve the 8 puzzle problem
;; INPUT
;;      found_goal   :: goal found in search
;;      visted       :: list of expanded nodes
;; OUTPUT
;;      Prints solution of the puzzle
(defun printSolution (visited found_goal)
    (format t "_________________________________")
    (let ( ( solution nil ) (parent (cdr found_goal))) 
        ;; add goal and its parent
        (setq solution (list parent (car found_goal)))
        
        ;; Loop untill nil parent is found
        (loop 
            (setq parent (cdr (find parent visited :key #'car )))
            (when (eq nil parent) (return nil))
            (setq solution (append (list parent) solution))
        )
        ;; print the solution
        (format t "~%~%Solution to 8 puzzle  ::~%" )
        (dolist (elem solution)
            (format t "~S~%" elem)
        )
    )
)

;; Recursive function to solve the 8 puzzle problem
;; INPUT
;;      goal   :: goal to find
;;      queue  :: frotier on which nodes to expanded resides
;;      visted :: list of expanded nodes
;; OUTPUT
;;      Prints solution of the puzzle
(defun findSol8P (goal queue visited)
    (if (null goal) (return-from findSol8P "NULL GOAL"))               ;; Goal is null
    (if (null queue) (return-from findSol8P "NULL QUEUE"))             ;; Queue is null
    (if (eq 0 (length queue) ) (return-from findSol8P "EMPTY QUEUE"))  ;; Queue is empty

    (let ( ( top (car queue) ) )
        ;; Solution found if queue start has goal
        (if (equalp (caar top) goal ) (return-from findSol8P (printSolution visited (car top)) ) )
        
        ;; Add node in visited list
        (setq visited (append visited (list (car top)) ) )
        (incf numExpanded 1)    ;; Expanding one node
            
        (setq queue (cdr queue))    ;; Removing top from queue
        (setq queue (append queue (getChild top queue visited) ) )  ;; Adding expanded node chilren
        (setq queue (sort queue #'< :key #'cdr) )   ;; Sorting the queue with respect to cost values
        
        ;; recursive call until goal is found
        (findSol8P goal queue visited)
    )
)

;; Function to check if a 8 puzzle problem state is solvable
;; INPUT
;;      st_state :: state to check
;; OUTPUT
;;      return   :: T if puzzle is unsolvable 
;;                  NIL if puzzle is solvable
(defun detectUnsolvable (st_state)
    ;; making state as linear array
    (let ( (count 0) (state (make-array '(8))) (index 0))
        (dotimes (i 3)
            (dotimes (j 3)
                (if (not (eq 'E (aref st_state i j))) 
                    (setf (aref state index) (aref st_state i j))
                    (decf index 1)
                )
                (incf index 1)
            )
        )
        ;; Counting number of inversions
        (dotimes (i 8)
            (loop for j from (+ 1 i) to 7
                do(if (> (aref state i) (aref state j)) (incf count 1))
            )
        )
        (if (oddp count) (return-from detectUnsolvable t))
    )
)

;; Function to solve 8 puzzle problem
;; INPUT
;;      initState ::
;; OUTPUT
;;      Print number of nodes expanded
(defun solve8Puzzle (initState)
    ; initialzing numExpanded to zero
    (setq numExpanded 0)

    ;; Inital state can not be null
    (if (null initState) (return-from solve8Puzzle "Null Initial State"))

    (let ( 
            ;; Setting intial state and goal as arrays
            (st_state (make-array '(3 3) :initial-contents initState))
            (goal     (make-array '(3 3) :initial-contents '( (1 2 3) (4 5 6) (7 8 E) ))) 
        )

        ;; Checking if puzzle is solvable or not
        (if (detectUnsolvable st_state) (return-from solve8Puzzle "Infeasible Puzzle"))
        
        ;; Calling find Solution function
        (findSol8P goal (list (cons (cons st_state nil) (heuristicFunc st_state))) nil)
        
        (format t "~%~%Number of Nodes expanded :: ~A" numExpanded)
        (format t "~%~%")
        (setq numExpanded 0)    ;; Resetting numExpanded
    )

    (return-from solve8Puzzle t)
)
;; ########################################################################
;; ########################################################################
;; ########################################################################
;; ########################################################################